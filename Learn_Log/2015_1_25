title:activity的生命周期
author:徐冉

在创建一个activity的时候，如果没有为它指定一个布局文件，利用setcontentview绑定，那么会默认的为它提供一个window。虽然默认的界面看起来什么也没有，但是却默认的指定了很多的framelayout等等的控件。利用hierarchyviewer这个工具可以查看当前进程的具体细节。


一个activity的生命周期，在启动的时候要经历以下几个状态
oncreated
onstart
onresume

按下back的时候，要经历
onpause
onstop
ondestory


在一个activity被一个局部的activity遮盖的时候，旧的activity就会变到onpause的状态下，退出局部的那个activity旧的就又会呈现在我们面前，此时旧的activity就会经历onresume的状态。

当一个activity跳转到另外一个的时候，也就是说，旧的activity此时已经看不见了，看见的是新的活动。旧的activity就会经历pause,stop.如果从新的活动再次跳转回来的话，旧的activity就会restart,start,resume这三个状态。

但是这五个状态的顺序要注意，旧的activity先经历pause，然后就是新的activity的三个状态，最后才是旧的activity的stop状态。因为在启动activity的时候需要一个过程，在旧的没有完全不可见的时候，是不执行stop的。

在从新的跳转回旧的activity的时候，新的activity首先pause,然后旧的执行restart ,start, resume,新的activity此时stop,destory。

无论是跳转，还是跳回，或者是其他的切换动作，都是要先进入pause状态，然后做完要做的工作之后，再进行stop,destory等工作.




想要查看一个activity从pause到resume。要弹出一个新的窗体，半遮掩原来的activity才能看见。

通过添加一个dialog,失去焦点之后，发现并不能触发onpause状态，因为dialog不是利用activity来实现的，它这是一个控件。所以想让一个activity直接触发onpause然后触发onresume的时候，就要使用一个局部的activity来遮掩旧的activity，这样旧的activity才会直接到onpause.




Activity里面的保存，一般来说和两个函数有关： onSaveInstanceState(), onRestoreInstanceState().前者是在跳转的时候保存状态，导出的作用，后者是恢复，导入的作用。


一般来说，我们如果在某一个activity中放置了edit控件，输入了一些东西。然后在按下home键或者跳转到新的activity的时候，都会调用savainstancestate这个函数，对输入框内的东西进行一个保存操作。之所以会调用这个函数保存一些状态信息，是因为我们暂时关掉旧的activity并不是我们自己的意愿，而是系统出于需要才会执行的.


onRestoreInstanceState()用于恢复状态。这个函数不一定每次都会执行，只有在系统kill掉相应的进程之后，下一次才会执行他进行恢复操作.