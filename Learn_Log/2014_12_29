titile:日期函数，数学函数,集合函数, 捕捉异常,finally块
author:xuran

一、日期函数
日期函数主要在Date类里面，但是很多方法都过时了，被封装到其他的类中。
其中，抽象类是不能够实例化对象的，而且，如果一个方法被修饰为static的话，那么这个方法可以直接用类名.成员名的形式来调用。
java中普通的成员方法是必须通过类对象来调用的，不能够使用其他形式调用，不然不会出现this指针这个东西。对于静态的成员方法来说，
用类名.方法或者用对象名.方法的形式调用都是相同的。
calendar是一个已经封装好的类，里面存储了很多原来Date类里面过时的函数和方法，但是这首先是一个抽象类，不能实例化对象，并且，即使我们获取了和时间有关的信息，我们也不能直接输出，因为这些信息是封装在类中的。要用特定的方法把这些数据解析出来。


二.数学函数
Math类里面各种功能函数都是static的，也就是说基本都是通过类名来进行调用的。

三、集合函数List
集合也是一组数据的在一起，数组是许多个相同数据类型的元素在一起，大小是固定的。但是集合可以又不同种的数据组成，并且集合的长度会根据元素的多少而进行调整。在list这个接口上，主要实现的几个类比较重要：arraylist vector linkedlist.

四、集合函数set
set集合和其他集合不同的是，set集合里面不允许有相同的元素。TreeSet这种SET集合，是不能够像之前的list和数组进行迭代的，因为，这个集合里面的元素会自动进行排序，set集合内的元素是有序的。所以说，就要依靠一种叫做迭代器的东西，来遍历整个数组元素

五、集合函数-map
HashMap：利用键-值的映射，来作为map集合里面的一个元素。插入元素的函数不再是add，而是Put.而获取里面的元素的时候，要利用get(key)的形式获取到相应位置的值。不能让一个key值映射多个值，如果连续对同一个键值put两次不同的值，后面的一次会覆盖前面的值。集合里面的哥哥元素是无序的。
TreeMap：这个类型的map集合会根据键的自然顺序排序每一个映射关系。
map集合和其他的List，set集合不一样，其他的集合是基于collection的，他们添加和获取集合中元素的方法和map集合不一样，而且在map集合中，有键集，值集，映射关系集


六、捕捉异常
这里指定异常主要还是在程序运行阶段发生的异常，因为编译阶段关于语法错误的一场是由编译器来检查的，不用我们担心。程序运行当中的异常，会让我们的程序中断执行，为了能够让程序跳过错误的部分执行并且能够捕捉到异常.这就用到了try/catch机制。

try和watch一般来说都是一起来用的，一个try至少要和一个watch组合在一起。try部分里面主要放着我们觉得可能会出现问题的代码。catch后面有一个小括号，这个括号里面要放我们想要捕捉哪种异常的异常对象，catch后面的花括号放的是处理这种异常的代码。

try/catch机制主要是用来捕捉处理异常，不让代码出现异常之后立刻停止运行，而是按照我们在catch块中写的处理机制看是否能够修复那些已经出现的问题。但是catch也不是什么毛病都能治，catch后面的小括号内就是要存放我想捕捉的异常对象，也就是说，当我们运行一边程序出错的时候，如果这个程序报了一个异常，那么我们就可以把这种异常对象放在catch块的小括号内，这样，再出现这种异常，我们的程序不会立刻停止，会执行catch里面的代码，如果执行完毕异常能够得到解决，那么程序就会恢复正常。如果不能处理完成，那么程序会忽略这个异常，结束。如果我们在try块里面的代码发生的异常并不是我们在catch小括号内想要捕捉的异常，那么这个异常还是会抛出，让我们的程序终止。所以说，为了至少能够捕捉到代码的异常，可以让一个try配置多个catch语句来保证程序的正常运行。如果我们无论如何都不想我们的代码被人和异常中止程序，那么在最后一个catch捕捉异常的种类出，可以添加Exception e,exception是所有异常类的父类，所以，最后一个catch能够捕捉到所有的异常。但是把Exception放在最前面会报错。但是只要被catch捕捉到一个异常的话，那么其他catch块内的代码就不会再执行了。

try块内的代码不管怎么样都是要执行的，但是catch是不一定的，只有被捕捉到相应的异常，相对应的catch代码才会被执行。

异常在java里面是一个类,这个异常类也是一种类型。

异常是一种类，exception是所有异常类的父类。他有一个非常重要的子类是运行时异常类runtimeexception



七、finally块
finally和try/catch是一个组合，经常会搭配在一起用。try块是用来监听可能出现异常的代码的，catch块是用来捕捉到相应的异常的。而finally是不管之前的代码发不发生异常，我都要执行的部分。
可能会觉得，直接把这部分代码放在外面不就行了，但是如果一旦有异常出现，程序异常中断，比如在操作数据库，文件的时候，即使有异常出现，我们要做的，必须把数据库或者文件关闭，防止对数据造成破坏，这就用到了finally，finally块不管前面有没有异常，最后都会执行finally块内的数据。

执行路径有以下几种，try---finally  try---catch---finally